<HTML>
<HEAD><title> M_Map: A Mapping package for Matlab </title>
</HEAD>
<body bgcolor="FFF5EE">

<h1 align="center">M_Map: User's Guide v1.3d </a></h1>

<hr>
<center> <img src="./mlogo.gif">  </center> <br>



<hr>

<h2> <a name="p1">1. Getting started </a> </h2> <p>

First, get all the files, either as a <a href="http://www.ocgy.ubc.ca/~rich/m_map1.3.zip"> zip archive </a>or a <a href="http://www.ocgy.ubc.ca/~rich/m_map1.3.tar.gz"> gzipped tar-file </a>and unpack them. Now, start up Matlab (version 5 or higher). Make
sure that the toolbox is in your path. This can be done simply by 
<code>cd</code>'ing to the correct directory. 

<p>
Alternatively,
if you have unpacked them into
directory <code>/users/rich/m_map</code> (and <code>/users/rich/m_map/private</code>),
then you can add this to your search path:

<pre>
path(path,'/users/rich/m_map');
</pre>

or

<pre>
addpath /users/rich/m_map
</pre>

To follow along with this document, you would then use a Web-browser to open
<a href="./mapug.html"><code>file:/users/rich/m_map/map.html</code></a>, that
is, this HTML document.

<p>
(Note: you may want to install M_Map as a toolbox accessible to all
users. To do this, unpack the files into $MATLAB/toolbox/m_map, and
add that directory to the list defined in $MATLAB/toolbox/local/pathdef.m).

<p>
Instructions for installing the (optional) high-resolution bathymetry database are given
in <a href="#p9"> Section 9 </a>, and instructions for installing the (optional)
high-resolution GSHHS coastline database is given in <a href="#p9.5"> Section 10 </a>.
However, we should first check that the basic setup is OK.

<p>
To see an example map, try this:

<pre>
m_proj('oblique mercator');
m_coast;
m_grid;
</pre>

This is a line map of the Oregon/British Columbia coast, using an Oblique Mercator projection
(A few more complex maps can be generated by running the demo function <code>m_demo</code>).

<p>

The first line initializes the projection. Defaults are set for the different projection,
so you can easily see what a specific projection looks like, but all projections have a number
of optional parameters as well. To get the same map without using the defaults, you would use

<pre>
m_proj('oblique mercator','longitudes',[-132 -125], ...
       'latitudes',[56 40],'direction','vertical','aspect',.5);
</pre>

The exact meanings of the various options is given in <a href="#p2"> Section 2 </a>. However, notice
that longitudes are specified using a <em> signed </em> notation - East longitudes are positive,
whereas West longitudes are negative (Also note that a decimal degree notation is used, so that
a longitude of 120 30'W is specified as -120.5).

<p>

The second line draws a coastline, using the 1/4 degree database. Coastlines with greater
resolution can be drawn, using your own database (see also <a href="#p7"> Section 7 </a>). <code>m_coast</code>
can be called with various line parameters. For example,

<pre>
m_coast('linewidth',2,'color','r');
</pre>

draws a thicker red coastline. Filled coastlines can also be drawn, using the <code> 'patch' </code>
option (followed by any of the usual PATCH property/value pairs).

<pre>
m_coast('patch',[.7 .7 .7],'edgecolor','none');
</pre>

draws a coastline with a gray fill and no border.

<p>

The third line superimposes a grid. Although there are many possible options that can be used to
customize the appearance of the grid, defaults can always be used (as in the example). 
These options are discussed in <a href="#p4"> Section 4 </a>. You can get a list of the options
using the GET syntax:

<pre>
m_grid get
</pre>

which acts somewhat like the <code> get(gca) </code> syntax for regular plots.

<p>

Finally, suppose you  want to show and label the location of, say, a mooring at 129W, 48 30'N.

<pre>
[X,Y]=m_ll2xy(-129,48.5);
line(X,Y,'marker','square','markersize',4,'color','r');
text(X,Y,' M5','vertical','top');
</pre>

<p>
<code> m_ll2xy </code> (and its inverse <code>m_xy2ll</code>) convert from longitude/latitude coordinates to those of the
projection. Various clipping options can also be specified in converting to projection
coordinates. If you are willing to accept default clipping setting, you can
use the built-in functions  <code> m_line </code> and  <code> m_text </code>:
<pre>
m_line(-129,48.5,'marker','square','markersize',4,'color','r');
m_text(-129,48.5,' M5','vertical','top');
</pre>



<p>
Finally (!), we may want to alter the grid details slightly. Note that, a given map
must only be initialized once.

<pre>
clf
m_coast('patch',[.7 .7 .7],'edgecolor','none');
m_grid('xlabeldir','end','fontsize',10);
m_line(-129,48.5,'marker','square','markersize',4,'color','r');
m_text(-129,48.5,' M5','vertical','top');
</pre>
<center><img align="center" SRC="exobl2.gif"> 
</center>

<hr>

<h2> <a name="p2"> 2. Specifying projections  </a> </h2> <p>

In order to get a list of the current projections, 
<pre>
m_proj get
</pre>

or 

<pre>
m_proj('get');
</pre>

Which currently return the following list:

<pre>
Available projections are:
     Stereographic
     Orthographic 
     Azimuthal Equal-area
     Azimuthal Equidistant
     Gnomonic
     Satellite
     Albers Equal-Area Conic
     Lambert Conformal Conic
     Mercator
     Miller Cylindrical
     Equidistant Cylindrical
     Oblique Mercator
     Transverse Mercator
     Sinusoidal
     Gall-Peters
     Hammer-Aitoff
     Mollweide
     UTM
</pre>

If you want details about the possible options for any of these projections, add its name
to the above command, e.g.

<pre>
m_proj('get','stereographic');
     'Stereographic'                                   
     <,'lon&lt;gitude>',center_long>                      
     <,'lat&lt;itude>', center_lat>                       
     <,'rad&lt;ius>', ( degrees | [longitude latitude] )>
     <,'rec&lt;tbox>', ( 'on' | 'off' )>                  
</pre>

You can also get details about the current projection. For example, in order to 
see what the default parameters are for the sinusoidal projection, we first initialize it, 
and then use the <code> 'set' </code> option:

<pre>
m_proj('sinusoidal');
m_proj set
Current mapping parameters -
 Projection: Sinusoidal  (function: mp_tmerc)
 longitudes: -90  30 (centered at -30)       
 latitudes: -65  65                          
 Rectangular border: off                     
</pre>

In order to initialize a projection, you usually specify some location parameters that
define the geometry of the projection (longitudinal limits, central parallel, etc.), as well as parameters
that define the extent of the map (whether it is in a rectangular axis, what the border points
are, etc.). These vary slightly from projection to projection.

<p>
Two useful properties for projections are (1) the ability the preserve angles for differentially
small regions, and (2) the ability to preserve area. Projections satisfying the first condition
are called <em> conformal </em>, those satisfying the second are called <em> equal-area </em>.
No projection can be both. Many projections (especially global projections) are neither, instead
an attempt has been made to  aesthetically balance the errors in both conditions. 

<p>
Note: All projections (except UTM) are currently <em> spherical </em> rather than ellipsoidal. It is unlikely
that this will be a problem in normal usage.


<ol>
<h3><li> <a name="p2.1">  Azimuthal projections </h3>

Azimuthal projections are those in which points on the globe are projected onto a flat tangent
plane. Maps using these projections have the property that direction or azimuth from the center
point to all other points is shown correctly. Great circle routes passing through the
central point appear as straight lines (although great circles not passing through
the central point may appear curved).

These maps are usually drawn with circular boundaries.
The following parameters are needed to define an azimuthal projection:

<h4> <code>         <,'lon&lt;gitude>',center_long>  <br>
                    <,'lat&lt;itude>', center_lat>    </code> </h4> 
These parameters define the center point of the map. Maps are aligned so that the specified
longitude is vertical at the map center, with its northern end at the top. 
                  
<h4> <code>      <,'rad&lt;ius>', ( degrees | [longitude latitude] )> </code> </h4> 

This defines the extent of the map. Either an angular distance in degrees can be given (e.g. 90 for
a hemisphere), or the coordinates of a point on the boundary can be specified.

<h4> <code>      <,'rec&lt;tbox>', ( 'on' | 'off' | 'circle' )>     </code> </h4>              

The default is to enclose the map in a circular boundary (chosen using either of the latter
two options), but a rectangular one can also be
specified. However, rectangular maps are usually better drawn using a cylindrical or
conic projection of some sort.
 

<ol>
 <h4> <li>Stereographic </h4>

The stereographic projection is conformal, but not equal-area. This projection is often
used for polar regions. 

 <h4> <li>Orthographic </h4>

This projection is neither equal-area nor conformal, but resembles a perspective view of
the globe.

<h4> <li>Azimuthal Equal-Area </h4>

Sometimes called the Lambert azimuthal equal-area projection, this mapping is equal-area
but not conformal.

<h4> <li>Azimuthal Equidistant </h4>

This projection is neither equal-area nor conformal, but all distances and directions
from the central point are true. 

<h4><li> Gnomonic </h4>

This projection is neither equal-area nor conformal, but all straight lines on the map (not
just those through the center) are great circle routes. There is, however, a great degree of
distortion at the edges of the map, so maximum radii should be kept fairly small - 20 or
30 degrees at most.

<h4><li> Satellite </h4>

This is a perspective view of the earth, as seen by a satellite at a specified altitude. Instead
of specifying a <code>radius</code> for the map, the viewpoint altitude is specified:

<h4> <code>      <,'alt&lt;itude>', altitude_fraction > </code> </h4> 

the numerical value assigned to this property represents the height of the viewpoint in units
of earth radii. For example, a satellite in an orbit of radius 3 earth radii would have an
altitude of 2.

</ol>

 <h3> <li><a name="p2.2"> Cylindrical and Pseudo-cylindrical Projections </h3>

Cylindrical projections are formed by projecting points onto a plane wrapped around the
globe, touching only along some great circle. These  are very useful projections for
showing regions of great lateral extent, and are also commonly used for global maps
of mid-latitude regions only. Also included here are two pseudo-cylindrical projections,
the sinusoidal and Gall-Peters, which have some 
similarities to the cylindrical projections (see below).

<p>
These maps are usually drawn with rectangular boundaries (with the exception of the
sinusoidal and sometimes the transverse mercator).


<ol>
 <h4><li>  Mercator </h4>

This is a conformal map, based on a tangent cylinder wrapped around the equator. Straight
lines on this projection are rhumb lines (i.e. the track followed by a course of constant
bearing). The following properties affect this projection:

<h4> <code>         <,'lon&lt;gitude>',( [min max] | center)>  </code> </h4>

Either longitude limits can be set, or a central longitude defined implying a global map.

 <h4> <code>        <,'lat&lt;itude>', ( maxlat | [min max])>    </code> </h4> 

Latitude limits are most usually the same in both N and S latitude, and can be specified with
a single value, but (if desired) unequal limits can also be used.

 <h4> <li>Miller Cylindrical </h4>

This projection is neither equal-area nor conformal, but "looks nice" for world maps. Properties
are the same as for the Mercator, above.

<h4> <li> Equidistant cylindrical </h4>

This projection is neither equal-area nor conformal. It consists of equally-spaced latitude
and longitude lines, and is very often used for quick plotting of data. It is included here
simply so that such maps can take advantage of the grid generation routines. Also known
as the Plate Carree. Properties
are the same as for the Mercator, above.


 <h4><li> Oblique Mercator </h4>

The oblique mercator arises when the great circle of tangency is arbitrary. This is a useful
projection for, e.g., long coastlines or other awkwardly shaped or aligned regions. It
is conformal but not equal area.
The following properties govern this projection:

<h4> <code>         <,'lon&lt;gitude>',[ G1 G2 ]> <br>
                    <,'lat&lt;itude>', [ L1 L2 ]>  </code> </h4>

Two points specify a great circle, and thus the limits of this map (it is assumed that
the region near the shortest of the two arcs is desired). The 2 points are (G1,L1) and (G2,L2).

<h4> <code>     <,'asp&lt;ect>',value>   </code> </h4>  

This specifies the size of the map in the direction perpendicular to the great circle of tangency,
as a proportion of the length shown. An aspect ratio of 1 results in a square map, smaller numbers
result in skinnier maps. Aspect ratios >1 are possible, but not recommended.

<h4> <code>    <,'dir&lt;ection>',( 'horizontal' | 'vertical' ) </code> </h4>  

This specifies whether the great circle of tangency will be horizontal on the page (for making
short wide maps), or vertical (for tall thin maps).


 <h4><li>  Transverse Mercator </h4>

The Transverse Mercator is a special case of the oblique mercator when the great circle of tangency
lies along a meridian of longitude, and is therefore conformal. 
It is often used for large-scale maps and charts.
The following properties govern this projection:

<h4> <code>           <,'lon&lt;gitude>',[min max]>   <br>   
     <,'lat&lt;itude>',[min max]>    </code> </h4>
    
These specify the limits of the map.

<h4> <code>       <,'clo&lt;ngitude>',value>    </code> </h4> 
     
Although it makes most sense in general to specify the central meridian as the meridian of tangency
(this is the default), certain map classification systems (noteably UTM) use only a fixed
set of central longitudes, which may not be in the map center.

<h4> <code>       <,'rec&lt;tbox>', ( 'on' | 'off' )> </code> </h4>

The map limits can either be based on latitude/longitude (the default), or the map boundaries
can form an exact rectangle. The difference is small for large-scale maps. 


Note: Although this projection is similar to the Universal Transverse Mercator (UTM) projection,
the latter is actually ellipsoidal in nature.

 <h4><li>  Universal Transverse Mercator (UTM) </h4>

UTM maps are needed only for high-quality maps of small regions of the 
globe (less than a few degrees in longitude). This is an ellipsoidal projection. Options
are similar to those of the Transverse Mercator, with the addition of

<h4> <code>       <,'zon&lt;e>', value 1-60>    </code> </h4> 
<h4> <code>       <,'hem&lt;isphere>',value 0=N,1=S>    </code> </h4> 

These are computed automatically if not specified. The ellipsoid defaults to <code>'normal'</code>,
a spherical earth of radius 1 unit, but other options 
can also be chosen using the following property:

<h4> <code>       <,'ell&lt;ipsoid>', ellipsoid>    </code> </h4> 

For a list of available ellipsoids try <code>m_proj('get','utm')</code>.
<p>
The big difference between UTM and all
the other projections is that for ellipsoids other than <code>'normal'</code>
the projection coordinates are in meters of easting and
northing. To take full advantage of this it is often useful to call <code>m_proj</code>
with <code>'rectbox'</code> set to <code>'on'</code> and not to use the long/lat
grid generated by <code>m_grid</code> (since the regular matlab grid will be in units
of meters).

 <h4><li> Sinusoidal </h4>

This projection is usually called "pseudo-cylindrical" since parallels of latitude
appear
as straight lines, similar to their appearance in cylindrical projections tangent to the
equator. However, meridians curve together in this projection in a sinusoidal way (hence
the name), making this map equal-area.

 <h4><li> Gall-Peters </h4>

Parallels of latitude and meridians both appear as straight lines, but the vertical scale
is distorted so that area is preserved. This is useful for tropical areas, but
the distortion in polar areas is extreme.


</ol>

<h3> <li>   <a name="p2.3"> Conic Projections </h3>

Conic projections result from projecting onto a cone wrapped around the sphere. The vertex
of the cone lies on the rotational axis of the sphere. The cone is either
tangent at a single latitude, or can intersect the sphere at two separated latitudes.
It is a useful projection for mid-latitude areas of large east-west extent.
The following properties affect these projections:

<h4> <code>           <,'lon&lt;gitude>',[min max]>   <br>   
     <,'lat&lt;itude>',[min max]>    </code> </h4>
    
These specify the limits of the map.

<h4> <code>       <,'clo&lt;ngitude>',value>    </code> </h4> 
     
The central longitude appears as a vertical on the page. The default value is the mean
longitude, although it may be set to any value (even one outside the limits).

<h4> <code>     <,'par&lt;allels>',[lat1 lat2]>   </code> </h4>

The standard parallels can be specified. Either one or two parallels can be given, the default
is a single parallel at the mean latitude

<h4> <code>       <,'rec&lt;tbox>', ( 'on' | 'off' )> </code> </h4>

The map limits can either be based on latitude/longitude (the default), or the map boundaries
can form an exact rectangle which contain the given limits. Unless the region being mapped is
small, it is best to leave this <code> 'off' </code>.

<ol>
  <h4><li> Albers Equal-Area Conic </h4>

This projection is equal-area, but not conformal

  <h4><li> Lambert Conformal Conic </h4>

This projection is  conformal, but not equal-area.
</ol>

<h3> <li>   <a name="p2.4"> Miscellaneous global projections </h3>

There are a number of projections which don't really fit into any of the above
categories. Mostly these are global projections (i.e. they show the whole world),
and they have been designed to be "pleasing to the eye". I'm not sure what use
they are in general, but they make nice logos!
<ol>

  <h4><li> Hammer-Aitoff </h4>

An equal-area projection with curved meridians and parallels.

  <h4><li> Mollweide </h4>
  
Also called the Elliptical or Homolographic Equal-Area Projection. Parallels
are straight (and parallel) in this projection. Note that 
<a href="../map.html#e4">example 4</a> shows a rather sophisticated use designed
to reduce distortion, a more standard map can be made using

<pre>
m_proj('mollweide');
m_coast('patch','r');
m_grid('xaxislocation','middle');
</pre>

</ol>

<h3> <li> <a name="p2.5"> Yeah, but which projection should I use?</h3>

Well, it depends really on how large an area you are mapping. Usually, maps
of the whole world are Mercator, although often the Miller Cylindrical
projection looks better because it doesn't emphasize the polar areas as much.
Another choice is the Hammer-Aitoff or Mollweide (which has meridians curving together near the 
poles). Both are equal-area.
It's probably not a good idea to use these projections for maps that don't
have the equator somewhere near the middle. 

<p>
If you are plotting something with a large north/south extent, but not
very wide (say, North and South America, or the North and South Atlantic), then 
the Sinusoidal or Mollweide projections
will look pretty good. Another choice is the Transverse Mercator, although
that is usually used only for very large-scale maps. 

<p> 
For smaller areas within one hemisphere or other (say, Australia, the
United States, the Mediterranean, the North Atlantic) you might pick a conic
projection. The differences between the two available conic projections
are subtle, and if you don't know much about projections it probably won't
make much difference which one you use.

<p>
If you get smaller than that, it doesn't matter a whole lot which
projection you use. One projection I find useful in many cases is the Oblique
Mercator, since you can align it along a long (but narrow) coastal area.
If map limits along lines of longitude/latitude are OK, use a Transverse Mercator or Conic
Projection. The UTM projection is also useful.

<p>
Polar areas are traditionally mapped using a Stereographic projection, since
for some reason it looks nice to have a "bullseye" pattern of latitude lines.

<p>
If you want to get a quick idea of what any projection looks like, default
parameters for all functions are set for a "typical" usage, i.e. to
get a quick idea of what any projection looks like, you can
do so without having to figure out a lot of numerical values:

<pre>
m_proj('stereographic');  % Example for stereographic projection
m_coast;
m_grid;
</pre>

<p>

<h3> <li> <a name="p2.6">Map scales</h3>

M_Map usually scales the map so that it fits exactly within the current axes. If
you just want a nice picture (which is mostly the case) then this is exactly what you
need. On the other hand, sometimes you want to print things out at some exact scale
(i.e. if you really much prefer sitting at your desk with a ruler and a piece of
paper trying to figure out how far apart Bangkok and Tokyo are). Use the <code>m_scale</code>
primitive for this - for a 1:250000 map, call

<pre>
m_scale(250000);
</pre>

after you have drawn everything (Be careful - a 1:250000 map of the world is a lot
bigger than 8.5"x11" sheet of paper).

<p>
This option is usually only useful for large-scale maps, i.e. maps of very small
areas).

<p>
If you wish to know the current scale, calling <code>m_scale</code> without
any parameters will calculate and return that value.

<p> To return to the default scaling call <code>m_scale('auto')</code>.
<p>
(PS - If you do want to find distances from Bangkok to anywhere, plot an azimuthal 
equidistant
projection of the world centered on Bangkok (13 44'N, 100 30'E), 
and choose a fairly small scale, like 1:200,000,000). Another option would
be to use range rings, see <a href="../map.html#e11">example 11</a>.


</ol>


<hr>

<h2> <a name="p3"> 3. Coastlines and Bathymetry </a> </h2> <p>

M_Map includes two fairly simple databases for coastlines and global elevation data.
Highly-detailed databases are not included in this release because they
are a) extremely large and b) extremely
time-consuming to process (loops are inherently involved). If more detailed maps
are required, <a href="#p9"> section 9 </a> and <a href="#p9.5"> section 10 </a>
give instructions on how to add some freely-available high-resolution datasets.
Read <a href="#p7"> section 7 </a> and <a href="#p8"> section 8 </a> if you
want to add your own coastline/bathymetry data.

<ol>
<h2> <a name="p3.1"> <li> Coastline options  </a> </h2> <p>

M_Map includes a 1/4 degree resolution coastline database. This is suitable for maps
covering large portions of the globe, but is noticeably coarse for many large-scale
applications. Users not satisfied with their regional map are directed to
 <a href="#p7"> section 7 </a> and/or <a href="#p9.5"> section 10 </a>
for more information on creating and using high-resolution
coastlines.

The M_Map database is accessed using the <code> m_coast </code> function. Coastlines
can be drawn as simple lines, using

<pre>
m_coast('line', ...optional line arguments );
</pre>

or

<pre>
m_coast( optional line arguments );
</pre>

where the optional arguments are all the standard arguments for specifying line style, width,
color, etc.

Coastlines can also be drawn as filled patches using

<pre>
m_coast('patch', ...optional patch arguments );
</pre>

where the optional trailing arguments are the standard patch properties. For example,

<pre>
m_coast('patch',[.7 .7 .7],'edgecolor','g');
</pre>

draws gray land, outlined in green. 

When patches are being drawn, lakes and inland seas are given the axes background colour.

<p>
Note that line coastlines are usually drawn rather rapidly. Filled coastlines take considerably
more time to generate (because map limits are not necessarily rectangular, clipping must
be accomplished in m-files).

<h2> <a name="p3.2"> <li> Topography/Bathymetry options  </a> </h2> <p>

M_Map can access a 1-degree resolution global elevation database (actually, this database is
is included in the Matlab distribution, used by of <code>$MATLAB/toolbox/matlab/demos/earthmap.m</code>).
A contour map of elevations at default levels can be drawn using

<pre>
m_elev;
</pre>

Different levels can also be specified:

<pre>
m_elev('contour',LEVELS, optional contour arguments);
</pre>

For example, if you want all the contours to be dark blue, use:

<pre>
m_elev('contour',LEVELS,'edgecolor','b');
</pre>


Filled contours are also possible:

<pre>
m_elev('contourf',LEVELS, optional contourf arguments);
</pre>

Finally, if you want to simply extract the elevation data for your own purposes,

<pre>
[Z,LONG,LAT]=m_elev([LONG_MIN LONG_MAX LAT_MIN LAT_MAX]);
</pre>

returns rectangular matrices for depths Z at locations LONG,LAT.

</ol>
<hr>

<h2> <a name="p4"> 4. Customizing axes  </a> </h2> <p>

<ol>
<h3> <a name="p4.1"><li> Grid lines and labels </h3>

In order to get the perfect grid, you may want to experiment with different grid options. Two
functions are useful here, M_GRID which draws a grid, and M_UNGRID which erases the current
grid (but leaves all coastlines and user-specified data alone). Try

<pre>
m_proj('Lambert');
m_coast;
m_grid;
</pre>

to get a Lambert conic projection of North America. Now try

<pre>
m_ungrid
</pre>

The coastline is still there, but the grid has disappeared and the axes shows raw X/Y projection
coordinates. Now, try this:

<pre>
m_grid('xtick',10,'tickdir','out','yaxislocation','right','fontsize',7);
</pre>

The various options that can be changed are:

<h4> <code> 'box',( 'on' | 'off' | 'fancy' ) </code> </h4>

This specifies whether or not an outline box is drawn. Three types of outline
boxes are available: <code>'on'</code>, the default, is a a simple line. Two
types of fancy outline boxes are available. If <code>'tickdir'</code> is <code>'in'</code>,
then alternating black and white patches are made (see <a href="../map.html#e2">example 2</a>).
If <code>'tickdir'</code> is set to <code>'out'</code>, then a more complex line pattern
is drawn (see <a href="../map.html#e6">example 6</a>).
Fancy boxes are in general only available for maps bounded
by lat/long limits (i.e. not for azimuthal projections), but if this option is
chosen inappropriately a warning message is issued.


<h4> <code>      'xtick',( num | [value1 value2 ...])</code> </h4>

This specifies the number/location of the longitude grid. If a single number is specified,
grid lines/values are drawn for approximately that number of equally-spaced locations (the
number is only approximate because the M_GRID attempts to find "nice" intervals, i.e. it
rounds to even increments). Exact locations can be specified by using a vector of
location values. There is an analagous <code> 'ytick' </code> property.

<h4> <code>      'xticklabels',[label1;label2 ...]</code> </h4>

Special labels can be specified. Labels can either be numerical values (which are then formatted
by M_GRID), or string values which are used without change. There is an analagous 
<code> 'yticklabels' </code> property

<h4> <code>      'xlabeldir', ( 'middle' | 'end' )</code> </h4>

Longitude labels are either middled onto the ends of their prespective grid lines (and drawn
perpendicular to those lines), or are drawn extending outwards fro the ends of those lines.
There is an analagous 
<code> 'ylabeldir' </code> property.

<h4> <code>      'ticklen',value</code> </h4>

Specifies the length of tickmarks (as a fraction of plot width)

<h4> <code>      'tickdir',( 'in' | 'out' )</code> </h4>

Specifies whether tickmarks point inwards or outwards. If <code>'box'</code> is
set to <code>'fancy'</code>, this specifies the form of the fancy outline box.

 <h4> <code>     'color',colorspec <br>
      'linewidth', value <br>
  'linestyle', ( linespec | 'none' ) <br>
   'fontsize',value  <br>
    'fontname',name</code> </h4>

Specify various line/text properties for the grid and its labels.

<h4> <code>      'XaxisLocation',( 'bottom' | 'middle' | 'top' ) </code></h4>

Specifies where the X-axis will be drawn, either at the bottom (southermost) end, at
the top (northernmost) end, or in the middle.

<h4> <code>        'YaxisLocation',( 'left' | 'middle' | 'right' ) </code> </h4>

Specifies where the Y-axis will be drawn, either at the left (westernmostmost) end, at
the right (easternmost) end, or in the middle.

<h3> <a name="p4.2"><li> Titles and x/ylabels </h3>

Titles and x/ylabels can be added to maps using the <code>title</code> and 
<code>x/ylabel</code> functions in the usual way (this is a change from v1.0 in which
the 'visible' property had
to be explicitly set to 'on'; this is now done within m_grid).

</ol>
<hr>

<h2> <a name="p5">5.  Adding your own data  </a> </h2> <p>

The purpose of this package is to allow you to map your own data! Once a suitable
grid and (possibly) a coastline have been chosen, you can add your own lines, text,
or contour plots using built-in M_Map drawing functions which handle the conversion from
longitude/latitude coordinates to projection coordinates. These drawing functions are
very similar to the standard Matlab plotting functions, and are described in the 
<a href="#p5.3">next section</a>.

<p>
Sometimes you may want to convert between longitude/latitude and projection coordinates
without immediately plotting the data. This might happen if you want to interactively
select points using <code>ginput</code>, or if you want to draw labels tied to a
specific point on the screen rather than a particular longitude/latitude. Projection
conversion routines are described in sections <a href="#p5.1">5.2</a> and
<a href="#p5.2">5.3</a>. Once raw longitude/latitude coordinates are converted into
projection coordinates, standard Matlab plotting functions can be used.


<p>
Maps are drawn to fit within the boundaries of the plot axes. Thus their scale
is somewhat arbitrary. If you are interested in making a map to a given 
scale, e.g. 1:200000 or something like that, you can do so by using the
<code>m_scale</code> primitive, see <a href="#p2.6"> section 2.6 </a>.
The data units are the projection coordinates, which are distances expressed
as a fraction of earth radii. To get a map "distance" between two points,
use the Cartesian distance between the points in the projection coordinate
system and multiply by your favourite value for the earth's radius, usually
around 6370 km (exception - the UTM projection uses coordinates of northing and
easting in meters, so no conversion is necessary).



<p>
Caution: One problem that sometimes occurs is that data does not appear on the plot due to
ambiguities in longitude values. For example, if plot longitude limits are [-180 180],
a point with a longitude of, say, 200, may not appear in cylindrical and conic projections. 
This is not a bug. Handling the clipping in "wrapped around" curves requires
adding points (rather than just moving them) and is therefore incompatible with
various other requirements (such as keeping input and output matrices the same size
in the conversion routines described below).  

<ol>
<h3> <a name="p5.3"><li> Drawing lines, text, arrows, patches and contours </h3>

For most purposes you do not need to know what the projection coordinates actually
are - you just want to plot something at a specified longitude/latitude. 

Most of the time you when you want to plot something on a map you want to do so
by specifying longitude/latitude coordinates, instead of the usual X/Y locations. 
To do so in M_Map, replace  
calls 
to <code> line, text, quiver, patch,
contour, and contourf </code> with M_Map equivalents that recognize
lontgitude/latitude coordinates by prepending "m_" to the function name. For example,

<pre>
m_line(LONG,LAT,...line properties)   % draw a line on a map
m_quiver(LONG,LAT,U,V,S)              % A quiver plot
m_text(LONG,LAT,'string')             % Text
m_patch(LONG,LAT,..patch properties)  % Patches.
</pre>


Each of these functions will handle the coordinate conversion internally, and will 
return a vector of handles to the graphic objects if desired. The
only difference between these functions and the standard Matlab functions is that the first two
arguments MUST be longitude and latitude. 

<p>
Data gridded in longitude and latitude can also be contoured:

<pre>
m_contour(LONG,LAT,VALUES)
m_contourf(LONG,LAT,VALUES)
</pre>

Again, these functions will return handles to graphics objects, allowing (for example) the drawing of
labelled contours:

<pre>
[cs,h]=m_contour(LONG,LAT,VALUES)
clabel(cs,h,'fontsize',6);
</pre>

<p>
Fancy arrows (i.e. with width, head shape, and colour specifications) can be generated using
<code> m_vec.m </code>. See the on-line help for more details about the use of <code>m_vec</code>.

<h3> <a name="p5.4"><li> Drawing tracklines </h3>

It is sometimes useful to annotate lines representing the time-varying location of
a ship, aircraft, or satellite with time and date annotations. This can be done
using <code> m_track</code>. 

<pre>
m_proj('UTM','long',[-72 -68],'lat',[40 44]);
m_gshhs_i('color','k');
m_grid('box','fancy','tickdir','out');

% fake up a trackline
lons=[-71:.1:-67];
lats=60*cos((lons+115)*pi/180);
dates=datenum(1997,10,23,15,1:41,zeros(1,41));

m_track(lons,lats,dates,'ticks',0,'times',4,'dates',8,...
        'clip','off','color','r','orient','upright');  
</pre>
<center> <img src="./track1.gif">  </center> <br>

See the on-line help for more details about the use of <code>m_track</code>, and
the different options for setting fontsize, tick spacing, date formats, etc.

<p>
While fiddling with the various parameters, it is often handy to be able to erase
the plotted tracks without erasing the coastline and grid. This can be done using

<pre>
m_ungrid track
</pre>

or

<pre>
m_ungrid('track')
</pre>

<h3> <a name="p5.5"><li> Drawing range rings </h3>

One nifty thing that is sometimes useful is the ability to draw circles at a given range
or ranges from a specific location. This can be done using <code> m_range_ring</code>,
which has 3 required calling parameters: LONG, LAT, RANGE, followed by any number of
(optional) line specification property/value pairs. <a href="../map.html#e11">Example 11</a>
illustrates how to use <code>m_range_ring</code>.


<h3> <a name="p5.1"><li> Converting  longitude/latitude to projection coordinates </h3>

If you want to use projection coordinates (perhaps you want to compute map areas, or
distances, or you want to make a legend in the upper left corner), the following 
command converts longitude/latitude coordinates to 
projection coordinates. 

<pre>
[X,Y]=m_ll2xy(LONG,LAT, ...optional clipping arguments )
</pre>

where LONG, LAT, X, and Y are matrices of the same size. Projection coordinates are
equal to true distances near the center of the map, and are expressed as fractions
of an earth radius. To get a distance, multiply by the radius of the earth (about
6370km). The exception is the UTM projection which provides coordinates of northing
and easting in meters.

<p>
The possible clipping arguments are


<h4> <code>     'clip','on' </code> </h4>


This is the default. Columns of LONG and LAT are assumed to form lines, and these are clipped
to the map limits. The first point outside the map is therefore moved to the map edge,
and all other points are converted the NaN.


<h4> <code>     'clip','off' </code> </h4>


No clipping is performed. This is sometimes useful for debugging purposes.


<h4> <code>     'clip','point' </code> </h4>


Points are tested against the map limits. Those outside the limits are converted to NaN,
those inside are converted to projection coordinates. No points are moved. This option
is useful for point data (such as station locations).

<h4> <code>     'clip','patch' </code> </h4>


Points are tested against the map limits. Those outside the limits changed into a point exactly
on the limits. Those inside are converted to projection coordinates. This option
may be useful when trying to draw patches, however it probably won't work well.

<h3> <a name="p5.2"><li> Converting projection coordinates to longitude/latitude </h3>

Conversion from projection coordinates to longitude/latitude is straightforward:

<pre>
[LONG,LAT]=m_ll2xy(X,Y)
</pre>

There are no options.

</ol>


<hr>

<h2> <a name="p6">6.  More complex plots  </a> </h2> <p>

For ideas on how to make more complex plots, see the <a href="../map.html#examples">Examples</a>.
These plots are also included in the function <code>m_demo</code>.

<hr>

<h2> <a name="p13">7. Removing data from a plot  </a> </h2> <p>

<p>
Once a given map includes several elements a certain amount of fiddling is usually necessary
to satisfy the natural human urge to give the image a certain aesthetic quality. If the image
includes complicated coastlines which take a long time to draw 
(e.g. those discussed below) than clearing the figure and
redrawing soon becomes tedious. The <code>m_ungrid</code> command introduced above can be used
to selectively remove parts of the figure. For example:

<pre>
m_proj('lambert','long',[-160 -40],'lat',[30 80]);
m_coast;
m_range_ring(-123,49,[1e3:1e3:10e3],'color','r');
</pre>

draws range rings at 1000km increments from my office. But I am unsatisfied with this, and want
to redraw using only 200km increments. I can remove the effects of <code>m_range_ring</code>
and redraw using:

<pre>
m_ungrid range_ring
m_range_ring(-123,49,[200:200:2000],'color','r');
</pre>

In general the results of <code>m_ANYTHING</code> can be deleted by calling
<code>m_ungrid ANYTHING</code>.

<p>
<code>m_ungrid</code> can recognize and delete specific elements by searching  
the <code>'tag'</code> property of all plot elements, which is set by the various
different M_Map routines. 

<hr>

<h2> <a name="p7">8.  Adding your own coastlines  </a> </h2> <p>

If you are interested in a particular area and want a higher-resolution coastline than
that used by <code>m_coast</code>, the best procedure is to

<ol>
<li> Get a subset of points from some high-resolution database, and
<li> convert to screen coordinates using <code>m_ll2xy</code>, and plot.
</ol>

One place where high-resolution coastline data can be obtained is 
<a href="http://crusty.er.usgs.gov/coast/getcoast.html"> The Coastline Extractor</a>.
Follow the instructions there to get coastline data in a matlab-readable file,
and download to your computer. If the file is saved as "coast.dat", you can
plot it (as lines) using the following:

<pre>
load coast.dat
m_line(coast(:,1),coast(:,2));
</pre>

Filled coastlines will require more work. You should first read the instructions there 
on joining the coastline data into continuous segments. If you are lucky,
(i.e. no lakes or anything else), you <em>may</em> achieve success with

<pre>
load coast.dat
[X,Y]=m_ll2xy(coast(:,1),coast(:,2),'clip','patch');
k=[find(isnan(X(:,1)))];
for i=1:length(k)-1,
    x=coast([k(i)+1:(k(i+1)-1) k(i)+1],1);
    y=coast([k(i)+1:(k(i+1)-1) k(i)+1],2);
    patch(x,y,'r');
end;
</pre>

If this does not work, read the comments in <code>private/mu_coast</code>, orient the curves
in the desired fashion, and use <code>m_usercoast</code> to load your own data.

<ol>
<h3> <a name="p7.1"><li></a> DCW political boundaries </h3>

<p>
Files containing political boundaries for various countries and US states can be
downloaded from 
<a href="http://www.maproom.psu.edu/cgi-bin/ian/points/index.cgi">
http://www.maproom.psu.edu/cgi-bin/ian/points/index.cgi</a>. Once downloaded
to your machine use
<code>m_plotbndry</code> to access and plot the desired boundary. For example,
if you downloaded various US states into a subdirectory "states:,

<pre>
m_plotbndry('states/arizona','color,'r')
</pre>

would plot arizona on the current map.

</ol>
<hr>

<h2> <a name="p8">9.  Adding your own topography/bathymetry  </a> </h2> <p>

A number of global and regional topography databases are available at
<a href="http://www.scd.ucar.edu/dss/index.html"> NCAR </a>. Several are
available for free from 
<a href="http://www.scd.ucar.edu/dss/catalogs/free.html"> their ftp site</a>.

<p>
As long as the data is stored in a mat-file as a rectangular matrix in longitude/latitude,
then <code>m_contour</code> or <code>m_contourf</code> can be used to plot
that data.


<ol>
<h3> <a name="p8.1">  <li> </a> <a href="http://topex.ucsd.edu/marine_topo/text/topo.html">
Sandwell and Smith Bathymetry  </a> </h3> <p>

A recent new bathymetry with approximately 1km resolution in lower latitude areas
is being used by many people. This dataset is described at 
<a href="http://topex.ucsd.edu/marine_topo/text/topo.html">
http://topex.ucsd.edu/marine_topo/text/topo.html </a> and is available as a 134Mb binary file
at 
<a href="ftp://topex.ucsd.edu/pub/global_topo_2min/topo_6.2.img"> 
ftp://topex.ucsd.edu/pub/global_topo_2min/topo_6.2.img </a>. The authors have
included an m-file 
(<a href="ftp://topex.ucsd.edu/pub/global_topo_2min/matlab/mygrid_sand.m">mygrid_sand.m</a>)
which can extract portions of the data. Once this database (and the m-file) is installed
on your computer, you can use it in M_Map very easily. A typical usage is as follows:

<pre>
% Extract data
[elevations,lat,lon]=mygrid_sand([lat_south lat_north long_west long_east]);

% Use in M_Map command
m_contour(lon,lat,elevations);
</pre>

For some projections, you must make sure that the 'lon' values returned by
<code>mygrid_sand.m</code> fall within the range used in this projection
(i.e. you may have to add/subtract 360). This seems to happen all the time
for areas in the west (i.e. negative longitudes), if you forget this
you often end up with bewildering error messages about empty vectors!

</ol>

<hr>

<h2> <a name="p9">10. Using TerrainBase 5-minute global bathymetry/topography   </a> </h2> <p>

For many purposes the elevation database accessed by M_Map provides adequate
resolution. However, there are also many cases when more detail is desired. 
I have not included a higher-resolution database because
it would greatly increase the size of the package. However, v1.2 includes m-files
to access and plot a popular global 5-minute bathymetry/topography database,
after a few minutes of work.

<p>
This section provides instructions on how to download 
<a href="http://www.scd.ucar.edu/dss/datasets/ds759.2.html"> TerrainBase</a>, and convert
it from a 56Mb ASCII file to a 18Mb binary file using <code> m_tba2b.m</code>. It
is then straightforward to access and plot bathymetry from this file using 
<code> m_tbase.m</code>, which is in every way functionally identical to 
<code>m_elev</code> (see Section <a href="#p3.2">3.2</a>). 

<p>
TerrainBase is also available on CDrom, and is also
commonly stored in netcdf (or other) binary format somewhere on many academic networks. If
you modify <code> m_tbase.m </code> to access data from one of these
sources, let me know!

<p>
How to install TerrainBase:
<ol>
<li> get and uncompress the tbase.Z file from 
<a href="ftp://ncardata.ucar.edu/datasets/ds759.2/tbase.Z"> ftp://ncardata.ucar.edu/datasets/ds759.2/tbase.Z </a> into the m_map directory.
<p>
<li> Run  <code> m_tba2b('PATHNAME') </code> to store the resulting 18Mb binary
 file as <code> PATHNAME/tbase.int</code>.
<p>
<li> Delete the original ASCII file <code>tbase</code>.
<p>
<li> Edit the <code>PATHNAME</code> setting in <code>m_tbase</code> to 
point to the location of this file.

</ol>

That's it! Test things out with this map of the western mediterranean:
<pre>
m_proj('lambert','lon',[-10 20],'lat',[33 48]);
m_tbase('contourf');
m_grid('linestyle','none','tickdir','out','linewidth',3);
</pre>
<center> <img src="./extbase.gif">  </center> <br>

<h2> <a name="p9.5">11.  Using GSHHS high-resolution coastline database   </a> </h2> <p>

<ol>
<h3> <a name="p9.6"> <li> Installing GSHHS </h3> </a>

<p>
When drawing maps there is always a tradeoff between the execution time of the
generating program and the resolution of the resulting map. Included in M_Map
is a 1/4 degree coastline database which can be used to generate very fast maps,
with adequate resolution for many purposes.

<p>
However, it is often desirable to be able to make detailed maps of limited geographic
areas. For this purpose a higher-resolution coastline database is necessary.
I have not included such a database in M_Map because it would greatly increase
the size of the package. However, I have included m-files to access and use
a popular high-resolution database called <a
href="http://www.ngdc.noaa.gov/mgg/shorelines/gshhs.html"> GSHHS </a>

<p> 
As distributed, GSHHS consists of a hierarchical set of databases at different
resolutions. The lowest or "crude" resolution is not as good as the M_Map
database, although it contains many more inland lakes. The "high" resolution
consists of points about 200m apart. There is
also an even finer "full" resolution. You can install part or all of the
database (depending on how much disk space you have available). The "full" resolution 
occupies 90Mb of disk space, and successively coarser resolutions are smaller by about 1/4.
Thus "high" resolution occupies 21Mb,  "intermediate" uses 6Mb, and "low" uses 1.1Mb (one
reason for not always using "high" resolution is that the entire 90Mb database must be read
and processed each call, which may take some time).

<p>
How to install GSHHS:
<ol>
<li> Go to <a href="ftp://ftp.ngdc.noaa.gov/MGG/shorelines/" >
ftp://ftp.ngdc.noaa.gov/MGG/shorelines/ </a>.
<li> Get and uncompress any or all of the files <code> gshhs_c.b.gz,  
 gshhs_l.b.gz, gshhs_i.b.gz</code> and/or <code>gshhs_h.b.gz</code>
in a
convenient directory. One useful place is in <code>m_map/private</code>.

<li> If the database files are not in subdirectory <code> m_map/private </code>,
you must edit the <code>FILNAME</code> settings in <code>m_gshhs_c.m,
m_gshhs_l.m, m_gshhs_i.m, m_gshhs_h.m</code> and/or <code>m_gshhs_f.m</code>
</code>
to point to the appropriate files.
</ol>

<h3> <a name="p9.7"> <li> Using GSHHS effectively </h3> </a>

The simplest calling mechanism is identical to that for <code> m_coast </code>
(<a href="#p3"> Section 3 </a>). For example, to draw a gray-filled 
high-resolution coastline,

<pre>
m_gshhs_h('patch',[.5 .5 .5]);
</pre>

is sufficient. However, execution times may be very, very long, as the entire
database must be searched and processed. I would not recommend trying to draw world
maps with the intermediate or high-resolution coastlines! 
There are two ways to speed this up.
The first is merely to use a lower-resolution database, with fewer points.
The second is useful if
you are going to be repeatedly drawing
a map (because, for example, it's the base figure for your work). In
this case I recommend
that you save an intermediate processed (generally smaller) file as follows:

<pre>
m_proj ...  % set up projection parameters

% This command does not draw anything - it merely processes the 
% high-resolution database using the current projection parameters 
% to generate a smaller coastline file called "gumby"

m_gshhs_h('save','gumby');

% Now we can draw a few maps of the same area much more quickly

figure(1);
m_usercoast('gumby','patch','r');
m_grid;

figure(2);
m_usercoast('gumby','linewidth',2,'color','b');
m_grid('tickdir','out','yaxisloc','left');

etc.
</pre>



</pre>



</ol>
<hr>

<h2> <a name="p10">12. M_Map toolbox contents and description   </a> </h2> <p>


<ol>
<li>  Contents.m - toolbox contents
<li>  m_demo.m  - demonstrates a few maps.
</ol>

  User-callable functions
<ol>
<li>    m_proj.m   - initializes projections
<p>
<li>    m_grid.m   - draws grids
<li>    m_scale.m  - forces map to a given scale
<p>
<li>    m_ungrid.m - erases map elements (if you want to change parameters)
<p>
<li>    m_coast.m     - draws a coastline
<li>    m_elev.m      - draws elevation data
<li>    m_tbase.m     - draws elevation data from high-resolution database
<li>    m_gshhs_c.m   - draws coastline from GSHHS crude database
<li>    m_gshhs_l.m   - draws coastline from GSHHS low-resolution database
<li>    m_gshhs_i.m   - draws coastline from GSHHS intermediate-resolution database
<li>    m_gshhs_h.m   - draws coastline from GSHHS high-resolution database
<li>    m_gshhs_f.m   - draws coastline from GSHHS full resolution database
<li>    m_plotbndry.m - draws a political boundary from the DCW
<li>    m_usercoast.m - draws a coastline using a user-specified subset database.
<p>
<li>    m_line.m     - draws line data in map coords
<li>    m_text.m     - adds text data in map coords
<li>    m_patch.m    - adds patch data in map coords
<li>    m_quiver     - draws arrows for vector data
<li>    m_contour    - draws contour lines for gridded data
<li>    m_contourf   - draws filled contours
<li>    m_track      - draws annotated tracklines
<li>    m_range_ring - draws range rings
<p>
<li>    m_ll2xy.m    - converts from long/lat to map coordinates
<li>    m_xy2ll.m    - converts from map coordinates to long/lat
<p>
<li>    m_tba2b.m   - used in installing high-resolution elevation database.
<p>
<li>    m_vec.m     - fancy arrows
</ol>

  Internal functions (not meant to be user-callable)

<ol>
<li>    private/mp_azim.m  - azimuthal projections
<li>    private/mp_cyl.m   - cylindrical projections (equatorial)
<li>    private/mp_conic.m - conic projections
<li>    private/mp_tmerc.m - transverse cylindrical projections
<li>    private/mp_utm.m   - elliptical universal transverse cylindrical projections
<li>    private/mp_omerc.m - oblique cylindrical projection
<p>

<li>    private/mu_util.m   - various utility routines
<li>    private/mu_coast.m  - routines to handle coastlines.
<li>    private/clabel.m - patched version of clabel 
                         (matlab v5.1 version does not contain
                         capabilities for different text properties).    

<p>
<li>    private/m_coasts.mat - coastline data
</ol>

 HTML Documentation
<ol>
<li>  map.html  - documentation intro
<li>  private/mapug.html - users guide
<li>  various .gif - examples.
</ol>

<hr>

<h2> <a name="p11">13. Known Problems and Bugs   </a> </h2> <p>

<ol> 
<li>  Running M_Map on a PC with Matlab5.1 can sometimes produce a lot of

<pre>
> Warning: Divide by zero.
</pre>

messages. This is due to a bug in Matlab (actually due to the compiler TMW used) that 
results in an incorrect warning flag being set
when dividing some numbers by NaN. You can safely ignore these errors and
wait for v5.2
<p>
<li> If plotted data is coloured white, this will be changed to black in the postscript
output. This is due to the workings of the <code>print</code> command. 
In order to avoid this, set the figure background to white, i.e.

<pre>
set(gcf,'color','white')
</pre>

<p>
<li> If you are using filled contours, and the plot becomes "complicated" above
a certain level, it sometimes appears as if the contours are not filling properly,
i.e. you get a white map with contour lines but no colour.

<p> However, if you print the figure, the resulting postscript file (or plot)
will show the colours as expected. This appears to be a bug of some sort in
Matlab.

<p> If you want to see the colours in Matlab itself, try this:

<pre>
 set(findobj('tag','m_grid_color'),'facecolor','none') 
</pre>



</ol>


<h2> <a name="p11">14. Changes since last release   </a> </h2> <p>

<ol>
<p>
<li> Many, many internal changes in the way coastlines are handled. Code functionality
shifted, rearranged, etc. These changes should NOT
be visible to the user, please let me know if they are!
<p>
<li> m_scale, m_track, m_plotbndry, m_range_ring primitives
<p>
<li> Some small bugs in the patch algorithm for coastlines corrected.
<p>
<li> UTM projection
<p>
<li> Extented m_ungrid usage to all available plot elements (grids, coastlines, etc.)

</ol>

<hr>

<a href="../map.html"> Back to home page </a>


<hr>

<I> Last changed 1/Feb/1999. Questions and comments to 
  <a href="mailto:rich@ocgy.ubc.ca">rich@ocgy.ubc.ca</a>
 </I>
